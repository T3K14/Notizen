\documentclass[paper=a4,10pt]{scrartcl}

\usepackage[utf8x]{inputenc}
\usepackage[ngerman]{babel}
\usepackage[T1]{fontenc}

\usepackage{graphicx}
\usepackage{float}
\usepackage{subcaption}

\usepackage{fancyref}

\usepackage[numbers,square,sort]{natbib} %praktikumsquellenvorgabe
\usepackage{amsmath}
\usepackage{amssymb}

\usepackage{url}
\usepackage{hyperref}

\usepackage[a4paper, includehead, includefoot]{geometry}
\geometry{left=2cm, right=2cm, top=2cm, bottom=2cm}

\begin{document}

\title{Cpp}
%\author{Author's Name}
Diese Notizen basieren auf der Youtube-Reihe Cpp von $\{$ bis $\}$ von Bytes'n'Objects. 

\section{Todo}
\begin{itemize}
\item inline
\item perfect forwarding
\item SFINAE Prinzip?, enable\_if
\item auto
\item trailing return type
\item decltype
\item requires im Zsmhang mit concepts
\end{itemize}

\section{Initialisierungslisten}
In der Initialisierungsliste sollte man für die Initialisierung von Feldern einer Klasse keine anderen Felder der selben Klasse verwenden, sondern Konstruktorparameter oder Konstanten (Es sei denn man ist sich 100 prozentig sicher). Begründung ist, dass die Felder nicht entsprechend der Reihenfolge in der Liste initialisiert werden, sondern entsprechend der Deklaration in der Klasse.

\section{Rule of three}
Die drei sind: copy constructor, destructor und copy assignment operator. Und die Regel besagt, dass wenn ich einen von den drein in einer Klasse implementiere, sollte ich voraussichtlich auch die übrigen zwei mit implementieren.

\section{Pointer}
Man sollte statt nackten Pointern eigentlich nur shared-pointer verwenden.

\section{Weak pointer}
Wenn man auf einen Weak-pointer \texttt{w} der auf ein Objekt zeigt auf das kein shared-pointer mehr zeigt, bekommt man mit \texttt{w.lock()} wieder einen shared-pointer, der aber nicht gültig ist. Daher sollte man immer bevor man auf einen weak-pointer lock aufruft vorher mit \texttt{w.expired()} abchecken, ob das noch gültig ist. Oder man überprüft anschließend, ob der shared-pointer den man bekommt gültig ist. 

\section{struct}
Felder und Methoden einer Struct sind immer alle defaultmäßig public.

\section{aquisition is initialization}

\section{virtual und override}
Virtual Funktionen werden zur Laufzeit gebunden, also nicht schon beim compilen. D.h. man hat zB eine Basisklasse Haustier und weiss, dass jedes Haustier einen Laut von sich geben soll, dann kann man in der Basisklasse diese Funktionalitaet schon bereit stellen, aber wenn man dann die Klasse Katze hat, die von der Basisklasse erbt, kann man darin dann die Funktion umschreiben so dass der Laut auch zur Katze passt.
Das Program muss also so compiliert werden, dass auch zur Laufzeit noch festgestellt werden kann, was man genau vor sich hat (welches spezielle Haustier zB.).

\subsection{override}
Ist ein modifier, der angibt, dass man gerade explizit eine Funktion aus der Basisklasse überschreibt. Damit kann verhindert werden, dass man sich vertippt und aus versehen doch nicht überschreibt

\section{int main() vs int main(void)}
Beide sind in cpp gleichbedeutend. Der Unterschied ist nur in C, da main() bedeutet, dass die Fkt mit beliebeig vielen Parametern aufgerufen werden kann, wobei main(void) sagt, dass die Fkt nur ohne Parameter aufgerufen werden kann.

\section{Inheritance/Vererbung}
In Cpp kann man bei der Vererbung die modes public, protected und private mit angeben. Das bedeutet zB am Bsp von public, dass public members der Baseklasse in der abgeleiteten Klasse auch public bleiben und die protected members bleiben protected.

Private scheint der default zu sein und das bedeutet, dass die public und protected member der baseklasse private in der abgeleiteten Klasse werden.

Member die in der Baseklasse schon private waren werden gar nicht mit vererbt.

\section{kleine Anmerkungen}
\paragraph{helper functions} sind globale Funktionen, die laut Markus zu bevorzugen sind

\section{Fragen}
\end{document}